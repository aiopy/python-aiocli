{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AIOCLI Un moderno ligero ejecutor de consola as\u00edncrono para construir CLIs con Python 3.7+ basado en el m\u00f3dulo est\u00e1ndar de Python argparse y type hints altamente inspirado en AIOHTTP y FastApi . Caracter\u00edsticas principales: Integraci\u00f3n nativa : Basado en (y totalmente compatible con) el m\u00f3dulo argparse de Python. Soporte as\u00edncrono : Maneja comandos a/s\u00edncronamente para cualquier tipo de aplicaci\u00f3n. Soporte serverless : Integracion con AWS Lambda , Azure Function y Google Cloud Function . Soporte para tests : Dise\u00f1ado para ser f\u00e1cil de ejecutar y probar. Requisitos Python 3.7+ Instalaci\u00f3n python3 -m pip install aiocli Ejemplo from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application () def _get_envs () -> dict [ str , str ]: return { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } def _get_logger ( envs : dict [ str , str ] = Depends ( _get_envs )) -> Logger : logger = getLogger ( envs [ 'LOGGER_NAME' ]) logger . setLevel ( envs [ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app ) Licencia MIT","title":"aiocli"},{"location":"#aiocli","text":"Un moderno ligero ejecutor de consola as\u00edncrono para construir CLIs con Python 3.7+ basado en el m\u00f3dulo est\u00e1ndar de Python argparse y type hints altamente inspirado en AIOHTTP y FastApi . Caracter\u00edsticas principales: Integraci\u00f3n nativa : Basado en (y totalmente compatible con) el m\u00f3dulo argparse de Python. Soporte as\u00edncrono : Maneja comandos a/s\u00edncronamente para cualquier tipo de aplicaci\u00f3n. Soporte serverless : Integracion con AWS Lambda , Azure Function y Google Cloud Function . Soporte para tests : Dise\u00f1ado para ser f\u00e1cil de ejecutar y probar.","title":"AIOCLI"},{"location":"#requisitos","text":"Python 3.7+","title":"Requisitos"},{"location":"#instalacion","text":"python3 -m pip install aiocli","title":"Instalaci\u00f3n"},{"location":"#ejemplo","text":"from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application () def _get_envs () -> dict [ str , str ]: return { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } def _get_logger ( envs : dict [ str , str ] = Depends ( _get_envs )) -> Logger : logger = getLogger ( envs [ 'LOGGER_NAME' ]) logger . setLevel ( envs [ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app )","title":"Ejemplo"},{"location":"#licencia","text":"MIT","title":"Licencia"},{"location":"features/","text":"AIOCLI funcionalidades AIOCLI provides you with the following: Integraci\u00f3n nativa Totalmente compatible con el m\u00f3dulo argparse de Python. Nada nuevo que aprender. Completamente tipado basado en el est\u00e1ndar de Python 3.7 type hints . Menos bugs, adaptado a los IDEs. Soporte As\u00edncrono Funciona y se espera gracias al m\u00e9todo run_app(...) como el de la librer\u00eda AIOHTTP . F\u00e1cil de usar. Permite establecer tu event loop , por defecto es get_event_loop() . Mejor integraci\u00f3n con terceros. Maneja las signal\u2019s life-cycle utilizando los CommandHook . Genial manejo de las se\u00f1ales UNIX. Inyecci\u00f3n de Dependencias Siempre deben de ser funciones \"sync\", async o yield . Soluciona varios problemas con aio. Cada dependencia puede a su vez tener dependencias como un \"grafo\". Evita liarla parda. Cada dependencia permite caching . Incre\u00edble rendimiento. Soporte para Serverless Proveedores Cloud: AWS Lambda, Azure Function y Google Cloud Function. Go serverless. A medida: Decorando la funci\u00f3n run_app y cambiando los valores de los argumentos por defecto. \u00bfAlgo m\u00e1s? Soporte de Estado Permite tener un contenedor para compartir entre comandos. Sin complicarse. Soporte para Tests Provee TestCommander y TestClient como utilidades. No hay m\u00e1s excusas para no hacer tests. Soporte para Editores en Visual Studio Code : en PyCharm :","title":"Features"},{"location":"features/#aiocli-funcionalidades","text":"AIOCLI provides you with the following:","title":"AIOCLI funcionalidades"},{"location":"features/#integracion-nativa","text":"Totalmente compatible con el m\u00f3dulo argparse de Python. Nada nuevo que aprender. Completamente tipado basado en el est\u00e1ndar de Python 3.7 type hints . Menos bugs, adaptado a los IDEs.","title":"Integraci\u00f3n nativa"},{"location":"features/#soporte-asincrono","text":"Funciona y se espera gracias al m\u00e9todo run_app(...) como el de la librer\u00eda AIOHTTP . F\u00e1cil de usar. Permite establecer tu event loop , por defecto es get_event_loop() . Mejor integraci\u00f3n con terceros. Maneja las signal\u2019s life-cycle utilizando los CommandHook . Genial manejo de las se\u00f1ales UNIX.","title":"Soporte As\u00edncrono"},{"location":"features/#inyeccion-de-dependencias","text":"Siempre deben de ser funciones \"sync\", async o yield . Soluciona varios problemas con aio. Cada dependencia puede a su vez tener dependencias como un \"grafo\". Evita liarla parda. Cada dependencia permite caching . Incre\u00edble rendimiento.","title":"Inyecci\u00f3n de Dependencias"},{"location":"features/#soporte-para-serverless","text":"Proveedores Cloud: AWS Lambda, Azure Function y Google Cloud Function. Go serverless. A medida: Decorando la funci\u00f3n run_app y cambiando los valores de los argumentos por defecto. \u00bfAlgo m\u00e1s?","title":"Soporte para Serverless"},{"location":"features/#soporte-de-estado","text":"Permite tener un contenedor para compartir entre comandos. Sin complicarse.","title":"Soporte de Estado"},{"location":"features/#soporte-para-tests","text":"Provee TestCommander y TestClient como utilidades. No hay m\u00e1s excusas para no hacer tests.","title":"Soporte para Tests"},{"location":"features/#soporte-para-editores","text":"en Visual Studio Code : en PyCharm :","title":"Soporte para Editores"},{"location":"release-notes/","text":"CHANGELOG 1.6.x Add State. Add CommandArgument based on argparse.add_argument function args. More Serverless wrappers (alibaba and oracle) added. Improve debug traces. Improve docs. 1.5.x Common Serverless wrappers (aws, az and gcp) added. Fix event loop issues closing it. Improve exception handlers matching. Improve docs. 1.4.x Add middleware handlers. Add exception handlers. Add docs. More types. More tests. 1.3.x Add Dependency Injection. Improve example. Improve README.md. 1.2.x Add command decorator. Add startup, shutdown and cleanup handler signals. Fix event loop issues when cancelling tasks. Improve exit code feature support. Fix Python 3.7 support with all_tasks function helper. Add example. Add GitHub actions pipeline. Improve tests. 1.1.x Fix exports. Improve README.md 1.0.x Add Comander. Add Runner. Add tests.","title":"Release notes"},{"location":"release-notes/#changelog","text":"","title":"CHANGELOG"},{"location":"release-notes/#16x","text":"Add State. Add CommandArgument based on argparse.add_argument function args. More Serverless wrappers (alibaba and oracle) added. Improve debug traces. Improve docs.","title":"1.6.x"},{"location":"release-notes/#15x","text":"Common Serverless wrappers (aws, az and gcp) added. Fix event loop issues closing it. Improve exception handlers matching. Improve docs.","title":"1.5.x"},{"location":"release-notes/#14x","text":"Add middleware handlers. Add exception handlers. Add docs. More types. More tests.","title":"1.4.x"},{"location":"release-notes/#13x","text":"Add Dependency Injection. Improve example. Improve README.md.","title":"1.3.x"},{"location":"release-notes/#12x","text":"Add command decorator. Add startup, shutdown and cleanup handler signals. Fix event loop issues when cancelling tasks. Improve exit code feature support. Fix Python 3.7 support with all_tasks function helper. Add example. Add GitHub actions pipeline. Improve tests.","title":"1.2.x"},{"location":"release-notes/#11x","text":"Fix exports. Improve README.md","title":"1.1.x"},{"location":"release-notes/#10x","text":"Add Comander. Add Runner. Add tests.","title":"1.0.x"},{"location":"advanced/exception_handler/","text":"Una manera de controlar las excepciones que se producen para evitar comportamientos inesperados y mapear tus exits codes es utilizando los exception handler que funcionan tanto por tipo. from typing import Dict , Any from aiocli.commander import Application , run_app from aiocli.commander_app import Command app = Application ( state = { 'hello' : 'world' }) @app . exception_handler ( typ = BaseException ) async def log_exception_handler ( err : BaseException , cmd : Command , args : Dict [ str , Any ]) -> int : print ( f 'Command: { cmd . name } Err: { err } ' ) return 1 @app . command ( name = 'foo' ) async def bad_handler () -> int : raise Exception ( 'Oh no!' ) if __name__ == '__main__' : run_app ( app , argv = [ 'foo' ])","title":"Exception handler"},{"location":"advanced/hooks/","text":"Los Hooks son una poderosa herramienta que permiten controlar el ciclo de vida de tu aplicaci\u00f3n. Hay 3 tipos de Hooks: on_startup : Donde inicializar\u00e1s tus dependencias por ejemplo. on_shutdown : Donde cerrar\u00e1s las conexiones por ejemplo. on_cleanup : Donde liberar\u00e1s la memoria por ejemplo. \u00a1Los hooks internos siempre ser\u00e1n ejecutados aunque hayan sido ignorados en la definici\u00f3n del Command! from aiocli.commander import Application , run_app from aiocli.commander_app import CommandArgument , State class FakeDatabaseConnection : def open ( self ) -> None : pass def query ( self , q : str ) -> None : print ( q ) def close ( self ) -> None : pass app = Application ( state = { 'db' : FakeDatabaseConnection ()}) @app . on_startup . append async def on_startup ( app_ : Application ) -> None : app_ . state [ 'db' ] . open () @app . on_shutdown . append async def on_shutdown ( app_ : Application ) -> None : app_ . state [ 'db' ] . close () @app . on_cleanup . append async def on_cleanup ( app_ : Application ) -> None : app_ . state [ 'db' ] = None @app . command ( name = 'greet:to' , positionals = [ CommandArgument ( name_or_flags = '--name' )]) async def handle_show_greeting_query ( name : str , state : State ) -> int : state [ 'db' ] . query ( f 'SELECT greeting from greetings WHERE name=\" { name } \" LIMIT 1;' ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'greet:to' , '--name' , 'hook!' ])","title":"Hooks"},{"location":"advanced/middleware/","text":"Los middleware son un poderoso mecanismo que se ejecuta en secuencia antes del command handler permitiendo interceptar el comando y los argumentos ya resueltos. from datetime import datetime from typing import Any , Dict from aiocli.commander import Application , run_app from aiocli.commander_app import Command , CommandArgument def info_middleware ( cmd : Command , args : Dict [ str , Any ]) -> None : print ( f 'Command: { cmd . name } Arguments: { args } ' ) app = Application ( middleware = [ info_middleware ]) @app . middleware () async def time_middleware () -> None : print ( f 'Time: { datetime . now () } ' ) @app . command ( name = 'greet:to' , positionals = [ CommandArgument ( name_or_flags = '--name' )]) async def handle_greeting ( name : str ) -> int : print ( f 'Hello { name } ' ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'greet:to' , '--name' , 'middleware!' ])","title":"Middleware"},{"location":"advanced/serverless_support/","text":"con AWS Lambda : from aiocli.commander import Application from aiocli.commander_app_wrappers import aws_run_app app = Application () def _parser ( event , context ) -> list [ str ]: pass handler = aws_run_app ( app , parser = _parser ) con Azure Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import az_run_app app = Application () def _parser ( req , context ) -> list [ str ]: pass handler = az_run_app ( app , parser = _parser ) con Google Cloud Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import gcp_run_app app = Application () def _http_parser ( request ) -> list [ str ]: pass http_handler = gcp_run_app ( app , parser = _http_parser ) def _event_parser ( event_or_data , context ) -> list [ str ]: pass event_handler = gcp_run_app ( app , parser = _event_parser ) con Alibaba Cloud Function Compute : from aiocli.commander import Application from aiocli.commander_app_wrappers import alibaba_run_app app = Application () def _http_parser ( environ , start_response ) -> list [ str ]: pass http_handler = alibaba_run_app ( app , parser = _http_parser ) def _event_parser ( event , context ) -> list [ str ]: pass event_handler = alibaba_run_app ( app , parser = _event_parser ) con Oracle Cloud Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import oracle_run_app app = Application () def _parser ( ctx , data ) -> list [ str ]: pass handler = oracle_run_app ( app , parser = _parser )","title":"Serverless support"},{"location":"advanced/state/","text":"El State en aiocli nos permite mantener nuestras dependencias en la aplicaci\u00f3n y modificarlo (si es necesario) d\u00f3nde queramos. from aiocli.commander import Application , run_app from aiocli.commander_app import State app = Application ( state = { 'hello' : 'world' }) @app . command ( name = 'show:state' ) async def handle_show_state ( state : State ) -> int : print ( state ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'show:state' ])","title":"State"},{"location":"advanced/test_support/","text":"Has utilizado el plugin pytest-aiohttp ? Esto est\u00e1 inspirado en ello. # code: python3 <file.py> <command> <positionals> <optionals> from aiocli.commander import run_app , Application app = Application ( default_exit_code = 1 ) @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World' })]) async def handle_greeting ( name : str ) -> int : print ( f 'Hello { name } ' ) return 0 if __name__ == '__main__' : run_app ( app ) # test: pytest <test_file.py> from aiocli.test_utils import TestClient , TestCommander import pytest @pytest . mark . asyncio async def test_handle_greeting_command () -> None : commander = TestCommander ( app ) client = TestClient ( commander ) try : await commander . start_commander () args = 'greet:to --name aiocli' exit_code = await client . handle ( args . split ( ' ' ), timeout = float ( 1 ), timeout_exit_code = 134 , ) assert exit_code == 0 finally : await commander . close ()","title":"Test support"}]}