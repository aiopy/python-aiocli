{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AIOCLI A modern, lightweight, async console runner for building CLIs with Python 3.7+ based on standard Python's argparse module and type hints highly inspired by AIOHTTP and FastApi . Key Features: Native-based : Based on (and fully compatible with) Python's argparse module. Async support : Handle commands completely async thinking in smaller and larger apps. Serverless support : Wrappers for AWS Lambda , Azure Function and Google Cloud Function . Test support : Designed to be easy to execute and test. Requirements Python 3.7+ Installation python3 -m pip install aiocli Example from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application ( state = { 'envs' : { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } }) def _get_logger ( state : State ) -> Logger : logger = getLogger ( state . get ( 'envs' )[ 'LOGGER_NAME' ]) logger . setLevel ( state . get ( 'envs' )[ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app ) License MIT","title":"aiocli"},{"location":"#aiocli","text":"A modern, lightweight, async console runner for building CLIs with Python 3.7+ based on standard Python's argparse module and type hints highly inspired by AIOHTTP and FastApi . Key Features: Native-based : Based on (and fully compatible with) Python's argparse module. Async support : Handle commands completely async thinking in smaller and larger apps. Serverless support : Wrappers for AWS Lambda , Azure Function and Google Cloud Function . Test support : Designed to be easy to execute and test.","title":"AIOCLI"},{"location":"#requirements","text":"Python 3.7+","title":"Requirements"},{"location":"#installation","text":"python3 -m pip install aiocli","title":"Installation"},{"location":"#example","text":"from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application ( state = { 'envs' : { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } }) def _get_logger ( state : State ) -> Logger : logger = getLogger ( state . get ( 'envs' )[ 'LOGGER_NAME' ]) logger . setLevel ( state . get ( 'envs' )[ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app )","title":"Example"},{"location":"#license","text":"MIT","title":"License"},{"location":"features/","text":"AIOCLI features AIOCLI provides you with the following: Native-based Full compatible with Python's argparse module . Nothing new to learn. Completely typed based on standard Python 3.7 type hints . Fewer bugs, IDEs friendly. Async support Works and awaited through run_app(...) method like AIOHTTP library. Easy to use. Allow set an event loop , by default get_event_loop() . Better third party integrations. Handle signal\u2019s life-cycle using CommandHook s. Great UNIX signals management. Dependency Injection Always must be functions whether kind be \"sync\", async or yield . Solves several aio issues. Each dependency can have dependencies like a \"graph\". Avoid making a mess. Each dependency allows caching . Better performance. Serverless support Cloud providers: AWS Lambda, Azure Function and Google Cloud Function. Go serverless. Custom: Wrapping run_app function and changing default argument values. Anything else? State support Allow to have a container to share between commands. No complications. Test support Provides TestCommander and TestClient utilities. No more excuses not to test. Editor support in Visual Studio Code : in PyCharm :","title":"Features"},{"location":"features/#aiocli-features","text":"AIOCLI provides you with the following:","title":"AIOCLI features"},{"location":"features/#native-based","text":"Full compatible with Python's argparse module . Nothing new to learn. Completely typed based on standard Python 3.7 type hints . Fewer bugs, IDEs friendly.","title":"Native-based"},{"location":"features/#async-support","text":"Works and awaited through run_app(...) method like AIOHTTP library. Easy to use. Allow set an event loop , by default get_event_loop() . Better third party integrations. Handle signal\u2019s life-cycle using CommandHook s. Great UNIX signals management.","title":"Async support"},{"location":"features/#dependency-injection","text":"Always must be functions whether kind be \"sync\", async or yield . Solves several aio issues. Each dependency can have dependencies like a \"graph\". Avoid making a mess. Each dependency allows caching . Better performance.","title":"Dependency Injection"},{"location":"features/#serverless-support","text":"Cloud providers: AWS Lambda, Azure Function and Google Cloud Function. Go serverless. Custom: Wrapping run_app function and changing default argument values. Anything else?","title":"Serverless support"},{"location":"features/#state-support","text":"Allow to have a container to share between commands. No complications.","title":"State support"},{"location":"features/#test-support","text":"Provides TestCommander and TestClient utilities. No more excuses not to test.","title":"Test support"},{"location":"features/#editor-support","text":"in Visual Studio Code : in PyCharm :","title":"Editor support"},{"location":"release-notes/","text":"CHANGELOG 1.6.x Add State. Add CommandArgument based on argparse.add_argument function args. More Serverless wrappers (alibaba and oracle) added. Improve debug traces. Improve docs. 1.5.x Common Serverless wrappers (aws, az and gcp) added. Fix event loop issues closing it. Improve exception handlers matching. Improve docs. 1.4.x Add middleware handlers. Add exception handlers. Add docs. More types. More tests. 1.3.x Add Dependency Injection. Improve example. Improve README.md. 1.2.x Add command decorator. Add startup, shutdown and cleanup handler signals. Fix event loop issues when cancelling tasks. Improve exit code feature support. Fix Python 3.7 support with all_tasks function helper. Add example. Add GitHub actions pipeline. Improve tests. 1.1.x Fix exports. Improve README.md 1.0.x Add Comander. Add Runner. Add tests.","title":"Release notes"},{"location":"release-notes/#changelog","text":"","title":"CHANGELOG"},{"location":"release-notes/#16x","text":"Add State. Add CommandArgument based on argparse.add_argument function args. More Serverless wrappers (alibaba and oracle) added. Improve debug traces. Improve docs.","title":"1.6.x"},{"location":"release-notes/#15x","text":"Common Serverless wrappers (aws, az and gcp) added. Fix event loop issues closing it. Improve exception handlers matching. Improve docs.","title":"1.5.x"},{"location":"release-notes/#14x","text":"Add middleware handlers. Add exception handlers. Add docs. More types. More tests.","title":"1.4.x"},{"location":"release-notes/#13x","text":"Add Dependency Injection. Improve example. Improve README.md.","title":"1.3.x"},{"location":"release-notes/#12x","text":"Add command decorator. Add startup, shutdown and cleanup handler signals. Fix event loop issues when cancelling tasks. Improve exit code feature support. Fix Python 3.7 support with all_tasks function helper. Add example. Add GitHub actions pipeline. Improve tests.","title":"1.2.x"},{"location":"release-notes/#11x","text":"Fix exports. Improve README.md","title":"1.1.x"},{"location":"release-notes/#10x","text":"Add Comander. Add Runner. Add tests.","title":"1.0.x"},{"location":"advanced/exception_handler/","text":"One way to control the exceptions that occur to avoid unexpected behaviour and map your exits codes is to use exception handlers that work on a per type basis. from typing import Dict , Any from aiocli.commander import Application , run_app from aiocli.commander_app import Command app = Application ( state = { 'hello' : 'world' }) @app . exception_handler ( typ = BaseException ) async def log_exception_handler ( err : BaseException , cmd : Command , args : Dict [ str , Any ]) -> int : print ( f 'Command: { cmd . name } Err: { err } ' ) return 1 @app . command ( name = 'foo' ) async def bad_handler () -> int : raise Exception ( 'Oh no!' ) if __name__ == '__main__' : run_app ( app , argv = [ 'foo' ])","title":"Exception handler"},{"location":"advanced/hooks/","text":"Hooks are a powerful tool to control the lifecycle of your application. There are 3 types of Hooks: on_startup : Where you will initialise your dependencies for example. on_shutdown : Where you will close connections for example. on_cleanup : Where you will free up memory for example. Internal hooks will always be executed even if they are ignored on Command definition! from aiocli.commander import Application , run_app from aiocli.commander_app import CommandArgument , State class FakeDatabaseConnection : def open ( self ) -> None : pass def query ( self , q : str ) -> None : print ( q ) def close ( self ) -> None : pass app = Application ( state = { 'db' : FakeDatabaseConnection ()}) @app . on_startup . append async def on_startup ( app_ : Application ) -> None : app_ . state [ 'db' ] . open () @app . on_shutdown . append async def on_shutdown ( app_ : Application ) -> None : app_ . state [ 'db' ] . close () @app . on_cleanup . append async def on_cleanup ( app_ : Application ) -> None : app_ . state [ 'db' ] = None @app . command ( name = 'greet:to' , positionals = [ CommandArgument ( name_or_flags = '--name' )]) async def handle_show_greeting_query ( name : str , state : State ) -> int : state [ 'db' ] . query ( f 'SELECT greeting from greetings WHERE name=\" { name } \" LIMIT 1;' ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'greet:to' , '--name' , 'hook!' ])","title":"Hooks"},{"location":"advanced/middleware/","text":"Middleware are a powerful mechanism that is executed in sequence before the command handler allowing it to intercept the command and arguments already resolved. from datetime import datetime from typing import Any , Dict from aiocli.commander import Application , run_app from aiocli.commander_app import Command , CommandArgument def info_middleware ( cmd : Command , args : Dict [ str , Any ]) -> None : print ( f 'Command: { cmd . name } Arguments: { args } ' ) app = Application ( middleware = [ info_middleware ]) @app . middleware () async def time_middleware () -> None : print ( f 'Time: { datetime . now () } ' ) @app . command ( name = 'greet:to' , positionals = [ CommandArgument ( name_or_flags = '--name' )]) async def handle_greeting ( name : str ) -> int : print ( f 'Hello { name } ' ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'greet:to' , '--name' , 'middleware!' ])","title":"Middleware"},{"location":"advanced/serverless_support/","text":"with AWS Lambda : from aiocli.commander import Application from aiocli.commander_app_wrappers import aws_run_app app = Application () def _parser ( event , context ) -> list [ str ]: pass handler = aws_run_app ( app , parser = _parser ) with Azure Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import az_run_app app = Application () def _parser ( req , context ) -> list [ str ]: pass handler = az_run_app ( app , parser = _parser ) with Google Cloud Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import gcp_run_app app = Application () def _http_parser ( request ) -> list [ str ]: pass http_handler = gcp_run_app ( app , parser = _http_parser ) def _event_parser ( event_or_data , context ) -> list [ str ]: pass event_handler = gcp_run_app ( app , parser = _event_parser ) with Alibaba Cloud Function Compute : from aiocli.commander import Application from aiocli.commander_app_wrappers import alibaba_run_app app = Application () def _http_parser ( environ , start_response ) -> list [ str ]: pass http_handler = alibaba_run_app ( app , parser = _http_parser ) def _event_parser ( event , context ) -> list [ str ]: pass event_handler = alibaba_run_app ( app , parser = _event_parser ) with Oracle Cloud Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import oracle_run_app app = Application () def _parser ( ctx , data ) -> list [ str ]: pass handler = oracle_run_app ( app , parser = _parser )","title":"Serverless support"},{"location":"advanced/state/","text":"The State in aiocli allows us to keep our dependencies in the application and modify it (if necessary) wherever we want. from aiocli.commander import Application , run_app from aiocli.commander_app import State app = Application ( state = { 'hello' : 'world' }) @app . command ( name = 'show:state' ) async def handle_show_state ( state : State ) -> int : print ( state ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'show:state' ])","title":"State"},{"location":"advanced/test_support/","text":"Have you used the pytest-aiohttp plugin? This is inspired on it. # code: python3 <file.py> <command> <positionals> <optionals> from aiocli.commander import run_app , Application app = Application ( default_exit_code = 1 ) @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World' })]) async def handle_greeting ( name : str ) -> int : print ( f 'Hello { name } ' ) return 0 if __name__ == '__main__' : run_app ( app ) # test: pytest <test_file.py> from aiocli.test_utils import TestClient , TestCommander import pytest @pytest . mark . asyncio async def test_handle_greeting_command () -> None : commander = TestCommander ( app ) client = TestClient ( commander ) try : await commander . start_commander () args = 'greet:to --name aiocli' exit_code = await client . handle ( args . split ( ' ' ), timeout = float ( 1 ), timeout_exit_code = 134 , ) assert exit_code == 0 finally : await commander . close ()","title":"Test support"}]}