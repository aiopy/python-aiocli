{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AIOCLI A modern, lightweight, async console runner for building CLIs with Python 3.6+ based on standard Python's argparse module and type hints and highly inspired by AIOHTTP and FastApi . Key Features: Native-based : Based on (and fully compatible with) Python's argparse module. Async support : Handle commands completely async thinking in smaller and larger apps. Test support : Designed to be easy to execute and test. Requirements Python 3.6+ Installation pip install aiocli Example from logging import getLogger, Logger, StreamHandler from os import getenv from aiocli.commander import run_app, Application, Depends app = Application() def _get_envs() -> dict[str, str]: return { 'LOGGER_NAME': str(getenv('LOGGER_NAME', 'example_app')), 'LOGGER_LEVEL': str(getenv('LOGGER_LEVEL', 'INFO')), } def _get_logger(envs: dict[str, str] = Depends(_get_envs)) -> Logger: logger = getLogger(envs['LOGGER_NAME']) logger.setLevel(envs['LOGGER_LEVEL']) handler = StreamHandler() logger.addHandler(handler) return logger @app.command(name='greet:to', positionals=[('--name', {'default': 'World!'})]) async def handle_greeting(name: str, logger: Logger = Depends(_get_logger)) -> int: logger.info(f'Hello {name}') return 0 @app.command(name='div', optionals=[('--a', {'type': float}), ('--b', {'type': float})]) async def handle_division(a: float, b: float, logger: Logger = Depends(_get_logger)) -> int: try: logger.info(f'Result {a} / {b} = {(a / b)}') return 0 except BaseException as err: logger.error(f'Error: {err}') return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__': run_app(app) License MIT","title":"en"},{"location":"#aiocli","text":"A modern, lightweight, async console runner for building CLIs with Python 3.6+ based on standard Python's argparse module and type hints and highly inspired by AIOHTTP and FastApi . Key Features: Native-based : Based on (and fully compatible with) Python's argparse module. Async support : Handle commands completely async thinking in smaller and larger apps. Test support : Designed to be easy to execute and test.","title":"AIOCLI"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"pip install aiocli","title":"Installation"},{"location":"#example","text":"from logging import getLogger, Logger, StreamHandler from os import getenv from aiocli.commander import run_app, Application, Depends app = Application() def _get_envs() -> dict[str, str]: return { 'LOGGER_NAME': str(getenv('LOGGER_NAME', 'example_app')), 'LOGGER_LEVEL': str(getenv('LOGGER_LEVEL', 'INFO')), } def _get_logger(envs: dict[str, str] = Depends(_get_envs)) -> Logger: logger = getLogger(envs['LOGGER_NAME']) logger.setLevel(envs['LOGGER_LEVEL']) handler = StreamHandler() logger.addHandler(handler) return logger @app.command(name='greet:to', positionals=[('--name', {'default': 'World!'})]) async def handle_greeting(name: str, logger: Logger = Depends(_get_logger)) -> int: logger.info(f'Hello {name}') return 0 @app.command(name='div', optionals=[('--a', {'type': float}), ('--b', {'type': float})]) async def handle_division(a: float, b: float, logger: Logger = Depends(_get_logger)) -> int: try: logger.info(f'Result {a} / {b} = {(a / b)}') return 0 except BaseException as err: logger.error(f'Error: {err}') return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__': run_app(app)","title":"Example"},{"location":"#license","text":"MIT","title":"License"},{"location":"features/","text":"AIOCLI features AIOCLI provides you with the following: Native-based Full compatible with Python's argparse module . Nothing new to learn. Completely typed based on standard Python 3.6 type hints . Fewer bugs, IDEs friendly. Async support Works and awaited through run_app(...) method like AIOHTTP library. Easy to use. Allow set an event loop , by default get_event_loop() . Better third party integrations. Handle signal\u2019s life-cycle using CommandHook s. Great UNIX signals management. Dependency Injection Always must be functions whether kind be \"sync\", async or yield . Solves several aio issues. Each dependency can have dependencies like a \"graph\". Avoid making a mess. Each dependency allows caching . Better performance. Test support Provides TestCommander and TestClient utilities. No more excuses not to test. Editor support in Visual Studio Code : in PyCharm :","title":"Features"},{"location":"features/#aiocli-features","text":"AIOCLI provides you with the following:","title":"AIOCLI features"},{"location":"features/#native-based","text":"Full compatible with Python's argparse module . Nothing new to learn. Completely typed based on standard Python 3.6 type hints . Fewer bugs, IDEs friendly.","title":"Native-based"},{"location":"features/#async-support","text":"Works and awaited through run_app(...) method like AIOHTTP library. Easy to use. Allow set an event loop , by default get_event_loop() . Better third party integrations. Handle signal\u2019s life-cycle using CommandHook s. Great UNIX signals management.","title":"Async support"},{"location":"features/#dependency-injection","text":"Always must be functions whether kind be \"sync\", async or yield . Solves several aio issues. Each dependency can have dependencies like a \"graph\". Avoid making a mess. Each dependency allows caching . Better performance.","title":"Dependency Injection"},{"location":"features/#test-support","text":"Provides TestCommander and TestClient utilities. No more excuses not to test.","title":"Test support"},{"location":"features/#editor-support","text":"in Visual Studio Code : in PyCharm :","title":"Editor support"},{"location":"release-notes/","text":"\ud83d\udc77\u200d In progress...","title":"Release notes"},{"location":"advanced/intro/","text":"\ud83d\udc77\u200d In progress...","title":"Intro"},{"location":"tutorial/intro/","text":"\ud83d\udc77\u200d In progress...","title":"Intro"}]}