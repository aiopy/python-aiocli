{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AIOCLI A modern, lightweight, async console runner for building CLIs with Python 3.6+ based on standard Python's argparse module and type hints highly inspired by AIOHTTP and FastApi . Key Features: Native-based : Based on (and fully compatible with) Python's argparse module. Async support : Handle commands completely async thinking in smaller and larger apps. Serverless support : Wrappers for AWS Lambda , Azure Function and Google Cloud Function . Test support : Designed to be easy to execute and test. Requirements Python 3.6+ Installation python3 -m pip install aiocli Example from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application ( state = { 'envs' : { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } }) def _get_logger ( state : State ) -> Logger : logger = getLogger ( state . get ( 'envs' )[ 'LOGGER_NAME' ]) logger . setLevel ( state . get ( 'envs' )[ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app ) License MIT","title":"aiocli"},{"location":"#aiocli","text":"A modern, lightweight, async console runner for building CLIs with Python 3.6+ based on standard Python's argparse module and type hints highly inspired by AIOHTTP and FastApi . Key Features: Native-based : Based on (and fully compatible with) Python's argparse module. Async support : Handle commands completely async thinking in smaller and larger apps. Serverless support : Wrappers for AWS Lambda , Azure Function and Google Cloud Function . Test support : Designed to be easy to execute and test.","title":"AIOCLI"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"python3 -m pip install aiocli","title":"Installation"},{"location":"#example","text":"from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application ( state = { 'envs' : { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } }) def _get_logger ( state : State ) -> Logger : logger = getLogger ( state . get ( 'envs' )[ 'LOGGER_NAME' ]) logger . setLevel ( state . get ( 'envs' )[ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app )","title":"Example"},{"location":"#license","text":"MIT","title":"License"},{"location":"features/","text":"AIOCLI features AIOCLI provides you with the following: Native-based Full compatible with Python's argparse module . Nothing new to learn. Completely typed based on standard Python 3.6 type hints . Fewer bugs, IDEs friendly. Async support Works and awaited through run_app(...) method like AIOHTTP library. Easy to use. Allow set an event loop , by default get_event_loop() . Better third party integrations. Handle signal\u2019s life-cycle using CommandHook s. Great UNIX signals management. Dependency Injection Always must be functions whether kind be \"sync\", async or yield . Solves several aio issues. Each dependency can have dependencies like a \"graph\". Avoid making a mess. Each dependency allows caching . Better performance. Serverless support Cloud providers: AWS Lambda, Azure Function and Google Cloud Function. Go serverless. Custom: Wrapping run_app function and changing default argument values. Anything else? State support Allow to have a container to share between commands. No complications. Test support Provides TestCommander and TestClient utilities. No more excuses not to test. Editor support in Visual Studio Code : in PyCharm :","title":"Features"},{"location":"features/#aiocli-features","text":"AIOCLI provides you with the following:","title":"AIOCLI features"},{"location":"features/#native-based","text":"Full compatible with Python's argparse module . Nothing new to learn. Completely typed based on standard Python 3.6 type hints . Fewer bugs, IDEs friendly.","title":"Native-based"},{"location":"features/#async-support","text":"Works and awaited through run_app(...) method like AIOHTTP library. Easy to use. Allow set an event loop , by default get_event_loop() . Better third party integrations. Handle signal\u2019s life-cycle using CommandHook s. Great UNIX signals management.","title":"Async support"},{"location":"features/#dependency-injection","text":"Always must be functions whether kind be \"sync\", async or yield . Solves several aio issues. Each dependency can have dependencies like a \"graph\". Avoid making a mess. Each dependency allows caching . Better performance.","title":"Dependency Injection"},{"location":"features/#serverless-support","text":"Cloud providers: AWS Lambda, Azure Function and Google Cloud Function. Go serverless. Custom: Wrapping run_app function and changing default argument values. Anything else?","title":"Serverless support"},{"location":"features/#state-support","text":"Allow to have a container to share between commands. No complications.","title":"State support"},{"location":"features/#test-support","text":"Provides TestCommander and TestClient utilities. No more excuses not to test.","title":"Test support"},{"location":"features/#editor-support","text":"in Visual Studio Code : in PyCharm :","title":"Editor support"},{"location":"release-notes/","text":"CHANGELOG 1.6.x Add State. Add CommandArgument based on argparse.add_argument function args. More Serverless wrappers (alibaba and oracle) added. Improve debug traces. Improve docs. 1.5.x Common Serverless wrappers (aws, az and gcp) added. Fix event loop issues closing it. Improve exception handlers matching. Improve docs. 1.4.x Add middleware handlers. Add exception handlers. Add docs. More types. More tests. 1.3.x Add Dependency Injection. Improve example. Improve README.md. 1.2.x Add command decorator. Add startup, shutdown and cleanup handler signals. Fix event loop issues when cancelling tasks. Improve exit code feature support. Fix Python 3.6 support with all_tasks function helper. Add example. Add GitHub actions pipeline. Improve tests. 1.1.x Fix exports. Improve README.md 1.0.x Add Comander. Add Runner. Add tests.","title":"Release notes"},{"location":"release-notes/#changelog","text":"","title":"CHANGELOG"},{"location":"release-notes/#16x","text":"Add State. Add CommandArgument based on argparse.add_argument function args. More Serverless wrappers (alibaba and oracle) added. Improve debug traces. Improve docs.","title":"1.6.x"},{"location":"release-notes/#15x","text":"Common Serverless wrappers (aws, az and gcp) added. Fix event loop issues closing it. Improve exception handlers matching. Improve docs.","title":"1.5.x"},{"location":"release-notes/#14x","text":"Add middleware handlers. Add exception handlers. Add docs. More types. More tests.","title":"1.4.x"},{"location":"release-notes/#13x","text":"Add Dependency Injection. Improve example. Improve README.md.","title":"1.3.x"},{"location":"release-notes/#12x","text":"Add command decorator. Add startup, shutdown and cleanup handler signals. Fix event loop issues when cancelling tasks. Improve exit code feature support. Fix Python 3.6 support with all_tasks function helper. Add example. Add GitHub actions pipeline. Improve tests.","title":"1.2.x"},{"location":"release-notes/#11x","text":"Fix exports. Improve README.md","title":"1.1.x"},{"location":"release-notes/#10x","text":"Add Comander. Add Runner. Add tests.","title":"1.0.x"},{"location":"advanced/exception_handler/","text":"One way to control the exceptions that occur to avoid unexpected behaviour and map your exits codes is to use exception handlers that work on a per type basis. from typing import Dict , Any from aiocli.commander import Application , run_app from aiocli.commander_app import Command app = Application ( state = { 'hello' : 'world' }) @app . exception_handler ( typ = BaseException ) async def log_exception_handler ( err : BaseException , cmd : Command , args : Dict [ str , Any ]) -> int : print ( f 'Command: { cmd . name } Err: { err } ' ) return 1 @app . command ( name = 'foo' ) async def bad_handler () -> int : raise Exception ( 'Oh no!' ) if __name__ == '__main__' : run_app ( app , argv = [ 'foo' ])","title":"Exception handler"},{"location":"advanced/hooks/","text":"Hooks are a powerful tool to control the lifecycle of your application. There are 3 types of Hooks: on_startup : Where you will initialise your dependencies for example. on_shutdown : Where you will close connections for example. on_cleanup : Where you will free up memory for example. from aiocli.commander import Application , run_app from aiocli.commander_app import CommandArgument , State class FakeDatabaseConnection : def open ( self ) -> None : pass def query ( self , q : str ) -> None : print ( q ) def close ( self ) -> None : pass app = Application ( state = { 'db' : FakeDatabaseConnection ()}) @app . on_startup . append async def on_startup ( app_ : Application ) -> None : app_ . state [ 'db' ] . open () @app . on_shutdown . append async def on_shutdown ( app_ : Application ) -> None : app_ . state [ 'db' ] . close () @app . on_cleanup . append async def on_cleanup ( app_ : Application ) -> None : app_ . state [ 'db' ] = None @app . command ( name = 'greet:to' , positionals = [ CommandArgument ( name_or_flags = '--name' )]) async def handle_show_greeting_query ( name : str , state : State ) -> int : state [ 'db' ] . query ( f 'SELECT greeting from greetings WHERE name=\" { name } \" LIMIT 1;' ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'greet:to' , '--name' , 'hook!' ])","title":"Hooks"},{"location":"advanced/middleware/","text":"Middleware are a powerful mechanism that is executed in sequence before the command handler allowing it to intercept the command and arguments already resolved. from datetime import datetime from typing import Any , Dict from aiocli.commander import Application , run_app from aiocli.commander_app import Command , CommandArgument def info_middleware ( cmd : Command , args : Dict [ str , Any ]) -> None : print ( f 'Command: { cmd . name } Arguments: { args } ' ) app = Application ( middleware = [ info_middleware ]) @app . middleware () async def time_middleware () -> None : print ( f 'Time: { datetime . now () } ' ) @app . command ( name = 'greet:to' , positionals = [ CommandArgument ( name_or_flags = '--name' )]) async def handle_greeting ( name : str ) -> int : print ( f 'Hello { name } ' ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'greet:to' , '--name' , 'middleware!' ])","title":"Middleware"},{"location":"advanced/serverless_support/","text":"with AWS Lambda : from aiocli.commander import Application from aiocli.commander_app_wrappers import aws_run_app app = Application () def _parser ( event , context ) -> list [ str ]: pass handler = aws_run_app ( app , parser = _parser ) with Azure Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import az_run_app app = Application () def _parser ( req , context ) -> list [ str ]: pass handler = az_run_app ( app , parser = _parser ) with Google Cloud Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import gcp_run_app app = Application () def _http_parser ( request ) -> list [ str ]: pass http_handler = gcp_run_app ( app , parser = _http_parser ) def _event_parser ( event_or_data , context ) -> list [ str ]: pass event_handler = gcp_run_app ( app , parser = _event_parser ) with Alibaba Cloud Function Compute : from aiocli.commander import Application from aiocli.commander_app_wrappers import alibaba_run_app app = Application () def _http_parser ( environ , start_response ) -> list [ str ]: pass http_handler = alibaba_run_app ( app , parser = _http_parser ) def _event_parser ( event , context ) -> list [ str ]: pass event_handler = alibaba_run_app ( app , parser = _event_parser ) with Oracle Cloud Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import oracle_run_app app = Application () def _parser ( ctx , data ) -> list [ str ]: pass handler = oracle_run_app ( app , parser = _parser )","title":"Serverless support"},{"location":"advanced/state/","text":"The State in aiocli allows us to keep our dependencies in the application and modify it (if necessary) wherever we want. from aiocli.commander import Application , run_app from aiocli.commander_app import State app = Application ( state = { 'hello' : 'world' }) @app . command ( name = 'show:state' ) async def handle_show_state ( state : State ) -> int : print ( state ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'show:state' ])","title":"State"},{"location":"advanced/test_support/","text":"Have you used the pytest-aiohttp plugin? This is inspired on it. # code: python3 <file.py> <command> <positionals> <optionals> from aiocli.commander import run_app , Application app = Application ( default_exit_code = 1 ) @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World' })]) async def handle_greeting ( name : str ) -> int : print ( f 'Hello { name } ' ) return 0 if __name__ == '__main__' : run_app ( app ) # test: pytest <test_file.py> from aiocli.test_utils import TestClient , TestCommander import pytest @pytest . mark . asyncio async def test_handle_greeting_command () -> None : commander = TestCommander ( app ) client = TestClient ( commander ) try : await commander . start_commander () args = 'greet:to --name aiocli' exit_code = await client . handle ( args . split ( ' ' ), timeout = float ( 1 ), timeout_exit_code = 134 , ) assert exit_code == 0 finally : await commander . close ()","title":"Test support"},{"location":"en/","text":"AIOCLI A modern, lightweight, async console runner for building CLIs with Python 3.6+ based on standard Python's argparse module and type hints highly inspired by AIOHTTP and FastApi . Key Features: Native-based : Based on (and fully compatible with) Python's argparse module. Async support : Handle commands completely async thinking in smaller and larger apps. Serverless support : Wrappers for AWS Lambda , Azure Function and Google Cloud Function . Test support : Designed to be easy to execute and test. Requirements Python 3.6+ Installation python3 -m pip install aiocli Example from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application ( state = { 'envs' : { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } }) def _get_logger ( state : State ) -> Logger : logger = getLogger ( state . get ( 'envs' )[ 'LOGGER_NAME' ]) logger . setLevel ( state . get ( 'envs' )[ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app ) License MIT","title":"AIOCLI"},{"location":"en/#aiocli","text":"A modern, lightweight, async console runner for building CLIs with Python 3.6+ based on standard Python's argparse module and type hints highly inspired by AIOHTTP and FastApi . Key Features: Native-based : Based on (and fully compatible with) Python's argparse module. Async support : Handle commands completely async thinking in smaller and larger apps. Serverless support : Wrappers for AWS Lambda , Azure Function and Google Cloud Function . Test support : Designed to be easy to execute and test.","title":"AIOCLI"},{"location":"en/#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"en/#installation","text":"python3 -m pip install aiocli","title":"Installation"},{"location":"en/#example","text":"from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application ( state = { 'envs' : { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } }) def _get_logger ( state : State ) -> Logger : logger = getLogger ( state . get ( 'envs' )[ 'LOGGER_NAME' ]) logger . setLevel ( state . get ( 'envs' )[ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app )","title":"Example"},{"location":"en/#license","text":"MIT","title":"License"},{"location":"en/features/","text":"AIOCLI features AIOCLI provides you with the following: Native-based Full compatible with Python's argparse module . Nothing new to learn. Completely typed based on standard Python 3.6 type hints . Fewer bugs, IDEs friendly. Async support Works and awaited through run_app(...) method like AIOHTTP library. Easy to use. Allow set an event loop , by default get_event_loop() . Better third party integrations. Handle signal\u2019s life-cycle using CommandHook s. Great UNIX signals management. Dependency Injection Always must be functions whether kind be \"sync\", async or yield . Solves several aio issues. Each dependency can have dependencies like a \"graph\". Avoid making a mess. Each dependency allows caching . Better performance. Serverless support Cloud providers: AWS Lambda, Azure Function and Google Cloud Function. Go serverless. Custom: Wrapping run_app function and changing default argument values. Anything else? State support Allow to have a container to share between commands. No complications. Test support Provides TestCommander and TestClient utilities. No more excuses not to test. Editor support in Visual Studio Code : in PyCharm :","title":"Features"},{"location":"en/features/#aiocli-features","text":"AIOCLI provides you with the following:","title":"AIOCLI features"},{"location":"en/features/#native-based","text":"Full compatible with Python's argparse module . Nothing new to learn. Completely typed based on standard Python 3.6 type hints . Fewer bugs, IDEs friendly.","title":"Native-based"},{"location":"en/features/#async-support","text":"Works and awaited through run_app(...) method like AIOHTTP library. Easy to use. Allow set an event loop , by default get_event_loop() . Better third party integrations. Handle signal\u2019s life-cycle using CommandHook s. Great UNIX signals management.","title":"Async support"},{"location":"en/features/#dependency-injection","text":"Always must be functions whether kind be \"sync\", async or yield . Solves several aio issues. Each dependency can have dependencies like a \"graph\". Avoid making a mess. Each dependency allows caching . Better performance.","title":"Dependency Injection"},{"location":"en/features/#serverless-support","text":"Cloud providers: AWS Lambda, Azure Function and Google Cloud Function. Go serverless. Custom: Wrapping run_app function and changing default argument values. Anything else?","title":"Serverless support"},{"location":"en/features/#state-support","text":"Allow to have a container to share between commands. No complications.","title":"State support"},{"location":"en/features/#test-support","text":"Provides TestCommander and TestClient utilities. No more excuses not to test.","title":"Test support"},{"location":"en/features/#editor-support","text":"in Visual Studio Code : in PyCharm :","title":"Editor support"},{"location":"en/release-notes/","text":"CHANGELOG 1.6.x Add State. Add CommandArgument based on argparse.add_argument function args. More Serverless wrappers (alibaba and oracle) added. Improve debug traces. Improve docs. 1.5.x Common Serverless wrappers (aws, az and gcp) added. Fix event loop issues closing it. Improve exception handlers matching. Improve docs. 1.4.x Add middleware handlers. Add exception handlers. Add docs. More types. More tests. 1.3.x Add Dependency Injection. Improve example. Improve README.md. 1.2.x Add command decorator. Add startup, shutdown and cleanup handler signals. Fix event loop issues when cancelling tasks. Improve exit code feature support. Fix Python 3.6 support with all_tasks function helper. Add example. Add GitHub actions pipeline. Improve tests. 1.1.x Fix exports. Improve README.md 1.0.x Add Comander. Add Runner. Add tests.","title":"Release notes"},{"location":"en/release-notes/#changelog","text":"","title":"CHANGELOG"},{"location":"en/release-notes/#16x","text":"Add State. Add CommandArgument based on argparse.add_argument function args. More Serverless wrappers (alibaba and oracle) added. Improve debug traces. Improve docs.","title":"1.6.x"},{"location":"en/release-notes/#15x","text":"Common Serverless wrappers (aws, az and gcp) added. Fix event loop issues closing it. Improve exception handlers matching. Improve docs.","title":"1.5.x"},{"location":"en/release-notes/#14x","text":"Add middleware handlers. Add exception handlers. Add docs. More types. More tests.","title":"1.4.x"},{"location":"en/release-notes/#13x","text":"Add Dependency Injection. Improve example. Improve README.md.","title":"1.3.x"},{"location":"en/release-notes/#12x","text":"Add command decorator. Add startup, shutdown and cleanup handler signals. Fix event loop issues when cancelling tasks. Improve exit code feature support. Fix Python 3.6 support with all_tasks function helper. Add example. Add GitHub actions pipeline. Improve tests.","title":"1.2.x"},{"location":"en/release-notes/#11x","text":"Fix exports. Improve README.md","title":"1.1.x"},{"location":"en/release-notes/#10x","text":"Add Comander. Add Runner. Add tests.","title":"1.0.x"},{"location":"en/advanced/exception_handler/","text":"One way to control the exceptions that occur to avoid unexpected behaviour and map your exits codes is to use exception handlers that work on a per type basis. from typing import Dict , Any from aiocli.commander import Application , run_app from aiocli.commander_app import Command app = Application ( state = { 'hello' : 'world' }) @app . exception_handler ( typ = BaseException ) async def log_exception_handler ( err : BaseException , cmd : Command , args : Dict [ str , Any ]) -> int : print ( f 'Command: { cmd . name } Err: { err } ' ) return 1 @app . command ( name = 'foo' ) async def bad_handler () -> int : raise Exception ( 'Oh no!' ) if __name__ == '__main__' : run_app ( app , argv = [ 'foo' ])","title":"Exception handler"},{"location":"en/advanced/hooks/","text":"Hooks are a powerful tool to control the lifecycle of your application. There are 3 types of Hooks: on_startup : Where you will initialise your dependencies for example. on_shutdown : Where you will close connections for example. on_cleanup : Where you will free up memory for example. from aiocli.commander import Application , run_app from aiocli.commander_app import CommandArgument , State class FakeDatabaseConnection : def open ( self ) -> None : pass def query ( self , q : str ) -> None : print ( q ) def close ( self ) -> None : pass app = Application ( state = { 'db' : FakeDatabaseConnection ()}) @app . on_startup . append async def on_startup ( app_ : Application ) -> None : app_ . state [ 'db' ] . open () @app . on_shutdown . append async def on_shutdown ( app_ : Application ) -> None : app_ . state [ 'db' ] . close () @app . on_cleanup . append async def on_cleanup ( app_ : Application ) -> None : app_ . state [ 'db' ] = None @app . command ( name = 'greet:to' , positionals = [ CommandArgument ( name_or_flags = '--name' )]) async def handle_show_greeting_query ( name : str , state : State ) -> int : state [ 'db' ] . query ( f 'SELECT greeting from greetings WHERE name=\" { name } \" LIMIT 1;' ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'greet:to' , '--name' , 'hook!' ])","title":"Hooks"},{"location":"en/advanced/middleware/","text":"Middleware are a powerful mechanism that is executed in sequence before the command handler allowing it to intercept the command and arguments already resolved. from datetime import datetime from typing import Any , Dict from aiocli.commander import Application , run_app from aiocli.commander_app import Command , CommandArgument def info_middleware ( cmd : Command , args : Dict [ str , Any ]) -> None : print ( f 'Command: { cmd . name } Arguments: { args } ' ) app = Application ( middleware = [ info_middleware ]) @app . middleware () async def time_middleware () -> None : print ( f 'Time: { datetime . now () } ' ) @app . command ( name = 'greet:to' , positionals = [ CommandArgument ( name_or_flags = '--name' )]) async def handle_greeting ( name : str ) -> int : print ( f 'Hello { name } ' ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'greet:to' , '--name' , 'middleware!' ])","title":"Middleware"},{"location":"en/advanced/serverless_support/","text":"with AWS Lambda : from aiocli.commander import Application from aiocli.commander_app_wrappers import aws_run_app app = Application () def _parser ( event , context ) -> list [ str ]: pass handler = aws_run_app ( app , parser = _parser ) with Azure Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import az_run_app app = Application () def _parser ( req , context ) -> list [ str ]: pass handler = az_run_app ( app , parser = _parser ) with Google Cloud Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import gcp_run_app app = Application () def _http_parser ( request ) -> list [ str ]: pass http_handler = gcp_run_app ( app , parser = _http_parser ) def _event_parser ( event_or_data , context ) -> list [ str ]: pass event_handler = gcp_run_app ( app , parser = _event_parser ) with Alibaba Cloud Function Compute : from aiocli.commander import Application from aiocli.commander_app_wrappers import alibaba_run_app app = Application () def _http_parser ( environ , start_response ) -> list [ str ]: pass http_handler = alibaba_run_app ( app , parser = _http_parser ) def _event_parser ( event , context ) -> list [ str ]: pass event_handler = alibaba_run_app ( app , parser = _event_parser ) with Oracle Cloud Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import oracle_run_app app = Application () def _parser ( ctx , data ) -> list [ str ]: pass handler = oracle_run_app ( app , parser = _parser )","title":"Serverless support"},{"location":"en/advanced/state/","text":"The State in aiocli allows us to keep our dependencies in the application and modify it (if necessary) wherever we want. from aiocli.commander import Application , run_app from aiocli.commander_app import State app = Application ( state = { 'hello' : 'world' }) @app . command ( name = 'show:state' ) async def handle_show_state ( state : State ) -> int : print ( state ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'show:state' ])","title":"State"},{"location":"en/advanced/test_support/","text":"Have you used the pytest-aiohttp plugin? This is inspired on it. # code: python3 <file.py> <command> <positionals> <optionals> from aiocli.commander import run_app , Application app = Application ( default_exit_code = 1 ) @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World' })]) async def handle_greeting ( name : str ) -> int : print ( f 'Hello { name } ' ) return 0 if __name__ == '__main__' : run_app ( app ) # test: pytest <test_file.py> from aiocli.test_utils import TestClient , TestCommander import pytest @pytest . mark . asyncio async def test_handle_greeting_command () -> None : commander = TestCommander ( app ) client = TestClient ( commander ) try : await commander . start_commander () args = 'greet:to --name aiocli' exit_code = await client . handle ( args . split ( ' ' ), timeout = float ( 1 ), timeout_exit_code = 134 , ) assert exit_code == 0 finally : await commander . close ()","title":"Test support"},{"location":"es/","text":"AIOCLI Un moderno ligero ejecutor de consola as\u00edncrono para construir CLIs con Python 3.6+ basado en el m\u00f3dulo est\u00e1ndar de Python argparse y type hints altamente inspirado en AIOHTTP y FastApi . Caracter\u00edsticas principales: Integraci\u00f3n nativa : Basado en (y totalmente compatible con) el m\u00f3dulo argparse de Python. Soporte as\u00edncrono : Maneja comandos a/s\u00edncronamente para cualquier tipo de aplicaci\u00f3n. Soporte serverless : Integracion con AWS Lambda , Azure Function y Google Cloud Function . Soporte para tests : Dise\u00f1ado para ser f\u00e1cil de ejecutar y probar. Requisitos Python 3.6+ Instalaci\u00f3n python3 -m pip install aiocli Ejemplo from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application () def _get_envs () -> dict [ str , str ]: return { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } def _get_logger ( envs : dict [ str , str ] = Depends ( _get_envs )) -> Logger : logger = getLogger ( envs [ 'LOGGER_NAME' ]) logger . setLevel ( envs [ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app ) Licencia MIT","title":"AIOCLI"},{"location":"es/#aiocli","text":"Un moderno ligero ejecutor de consola as\u00edncrono para construir CLIs con Python 3.6+ basado en el m\u00f3dulo est\u00e1ndar de Python argparse y type hints altamente inspirado en AIOHTTP y FastApi . Caracter\u00edsticas principales: Integraci\u00f3n nativa : Basado en (y totalmente compatible con) el m\u00f3dulo argparse de Python. Soporte as\u00edncrono : Maneja comandos a/s\u00edncronamente para cualquier tipo de aplicaci\u00f3n. Soporte serverless : Integracion con AWS Lambda , Azure Function y Google Cloud Function . Soporte para tests : Dise\u00f1ado para ser f\u00e1cil de ejecutar y probar.","title":"AIOCLI"},{"location":"es/#requisitos","text":"Python 3.6+","title":"Requisitos"},{"location":"es/#instalacion","text":"python3 -m pip install aiocli","title":"Instalaci\u00f3n"},{"location":"es/#ejemplo","text":"from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application () def _get_envs () -> dict [ str , str ]: return { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } def _get_logger ( envs : dict [ str , str ] = Depends ( _get_envs )) -> Logger : logger = getLogger ( envs [ 'LOGGER_NAME' ]) logger . setLevel ( envs [ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app )","title":"Ejemplo"},{"location":"es/#licencia","text":"MIT","title":"Licencia"},{"location":"es/features/","text":"AIOCLI funcionalidades AIOCLI provides you with the following: Integraci\u00f3n nativa Totalmente compatible con el m\u00f3dulo argparse de Python. Nada nuevo que aprender. Completamente tipado basado en el est\u00e1ndar de Python 3.6 type hints . Menos bugs, adaptado a los IDEs. Soporte As\u00edncrono Funciona y se espera gracias al m\u00e9todo run_app(...) como el de la librer\u00eda AIOHTTP . F\u00e1cil de usar. Permite establecer tu event loop , por defecto es get_event_loop() . Mejor integraci\u00f3n con terceros. Maneja las signal\u2019s life-cycle utilizando los CommandHook . Genial manejo de las se\u00f1ales UNIX. Inyecci\u00f3n de Dependencias Siempre deben de ser funciones \"sync\", async o yield . Soluciona varios problemas con aio. Cada dependencia puede a su vez tener dependencias como un \"grafo\". Evita liarla parda. Cada dependencia permite caching . Incre\u00edble rendimiento. Soporte para Serverless Proveedores Cloud: AWS Lambda, Azure Function y Google Cloud Function. Go serverless. A medida: Decorando la funci\u00f3n run_app y cambiando los valores de los argumentos por defecto. \u00bfAlgo m\u00e1s? Soporte de Estado Permite tener un contenedor para compartir entre comandos. Sin complicarse. Soporte para Tests Provee TestCommander y TestClient como utilidades. No hay m\u00e1s excusas para no hacer tests. Soporte para Editores en Visual Studio Code : en PyCharm :","title":"Features"},{"location":"es/features/#aiocli-funcionalidades","text":"AIOCLI provides you with the following:","title":"AIOCLI funcionalidades"},{"location":"es/features/#integracion-nativa","text":"Totalmente compatible con el m\u00f3dulo argparse de Python. Nada nuevo que aprender. Completamente tipado basado en el est\u00e1ndar de Python 3.6 type hints . Menos bugs, adaptado a los IDEs.","title":"Integraci\u00f3n nativa"},{"location":"es/features/#soporte-asincrono","text":"Funciona y se espera gracias al m\u00e9todo run_app(...) como el de la librer\u00eda AIOHTTP . F\u00e1cil de usar. Permite establecer tu event loop , por defecto es get_event_loop() . Mejor integraci\u00f3n con terceros. Maneja las signal\u2019s life-cycle utilizando los CommandHook . Genial manejo de las se\u00f1ales UNIX.","title":"Soporte As\u00edncrono"},{"location":"es/features/#inyeccion-de-dependencias","text":"Siempre deben de ser funciones \"sync\", async o yield . Soluciona varios problemas con aio. Cada dependencia puede a su vez tener dependencias como un \"grafo\". Evita liarla parda. Cada dependencia permite caching . Incre\u00edble rendimiento.","title":"Inyecci\u00f3n de Dependencias"},{"location":"es/features/#soporte-para-serverless","text":"Proveedores Cloud: AWS Lambda, Azure Function y Google Cloud Function. Go serverless. A medida: Decorando la funci\u00f3n run_app y cambiando los valores de los argumentos por defecto. \u00bfAlgo m\u00e1s?","title":"Soporte para Serverless"},{"location":"es/features/#soporte-de-estado","text":"Permite tener un contenedor para compartir entre comandos. Sin complicarse.","title":"Soporte de Estado"},{"location":"es/features/#soporte-para-tests","text":"Provee TestCommander y TestClient como utilidades. No hay m\u00e1s excusas para no hacer tests.","title":"Soporte para Tests"},{"location":"es/features/#soporte-para-editores","text":"en Visual Studio Code : en PyCharm :","title":"Soporte para Editores"},{"location":"es/release-notes/","text":"CHANGELOG 1.6.x Add State. Add CommandArgument based on argparse.add_argument function args. More Serverless wrappers (alibaba and oracle) added. Improve debug traces. Improve docs. 1.5.x Common Serverless wrappers (aws, az and gcp) added. Fix event loop issues closing it. Improve exception handlers matching. Improve docs. 1.4.x Add middleware handlers. Add exception handlers. Add docs. More types. More tests. 1.3.x Add Dependency Injection. Improve example. Improve README.md. 1.2.x Add command decorator. Add startup, shutdown and cleanup handler signals. Fix event loop issues when cancelling tasks. Improve exit code feature support. Fix Python 3.6 support with all_tasks function helper. Add example. Add GitHub actions pipeline. Improve tests. 1.1.x Fix exports. Improve README.md 1.0.x Add Comander. Add Runner. Add tests.","title":"Release notes"},{"location":"es/release-notes/#changelog","text":"","title":"CHANGELOG"},{"location":"es/release-notes/#16x","text":"Add State. Add CommandArgument based on argparse.add_argument function args. More Serverless wrappers (alibaba and oracle) added. Improve debug traces. Improve docs.","title":"1.6.x"},{"location":"es/release-notes/#15x","text":"Common Serverless wrappers (aws, az and gcp) added. Fix event loop issues closing it. Improve exception handlers matching. Improve docs.","title":"1.5.x"},{"location":"es/release-notes/#14x","text":"Add middleware handlers. Add exception handlers. Add docs. More types. More tests.","title":"1.4.x"},{"location":"es/release-notes/#13x","text":"Add Dependency Injection. Improve example. Improve README.md.","title":"1.3.x"},{"location":"es/release-notes/#12x","text":"Add command decorator. Add startup, shutdown and cleanup handler signals. Fix event loop issues when cancelling tasks. Improve exit code feature support. Fix Python 3.6 support with all_tasks function helper. Add example. Add GitHub actions pipeline. Improve tests.","title":"1.2.x"},{"location":"es/release-notes/#11x","text":"Fix exports. Improve README.md","title":"1.1.x"},{"location":"es/release-notes/#10x","text":"Add Comander. Add Runner. Add tests.","title":"1.0.x"},{"location":"es/advanced/exception_handler/","text":"Una manera de controlar las excepciones que se producen para evitar comportamientos inesperados y mapear tus exits codes es utilizando los exception handler que funcionan tanto por tipo. from typing import Dict , Any from aiocli.commander import Application , run_app from aiocli.commander_app import Command app = Application ( state = { 'hello' : 'world' }) @app . exception_handler ( typ = BaseException ) async def log_exception_handler ( err : BaseException , cmd : Command , args : Dict [ str , Any ]) -> int : print ( f 'Command: { cmd . name } Err: { err } ' ) return 1 @app . command ( name = 'foo' ) async def bad_handler () -> int : raise Exception ( 'Oh no!' ) if __name__ == '__main__' : run_app ( app , argv = [ 'foo' ])","title":"Exception handler"},{"location":"es/advanced/hooks/","text":"Los Hooks son una poderosa herramienta que permiten controlar el ciclo de vida de tu aplicaci\u00f3n. Hay 3 tipos de Hooks: on_startup : Donde inicializar\u00e1s tus dependencias por ejemplo. on_shutdown : Donde cerrar\u00e1s las conexiones por ejemplo. on_cleanup : Donde liberar\u00e1s la memoria por ejemplo. from aiocli.commander import Application , run_app from aiocli.commander_app import CommandArgument , State class FakeDatabaseConnection : def open ( self ) -> None : pass def query ( self , q : str ) -> None : print ( q ) def close ( self ) -> None : pass app = Application ( state = { 'db' : FakeDatabaseConnection ()}) @app . on_startup . append async def on_startup ( app_ : Application ) -> None : app_ . state [ 'db' ] . open () @app . on_shutdown . append async def on_shutdown ( app_ : Application ) -> None : app_ . state [ 'db' ] . close () @app . on_cleanup . append async def on_cleanup ( app_ : Application ) -> None : app_ . state [ 'db' ] = None @app . command ( name = 'greet:to' , positionals = [ CommandArgument ( name_or_flags = '--name' )]) async def handle_show_greeting_query ( name : str , state : State ) -> int : state [ 'db' ] . query ( f 'SELECT greeting from greetings WHERE name=\" { name } \" LIMIT 1;' ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'greet:to' , '--name' , 'hook!' ])","title":"Hooks"},{"location":"es/advanced/middleware/","text":"Los middleware son un poderoso mecanismo que se ejecuta en secuencia antes del command handler permitiendo interceptar el comando y los argumentos ya resueltos. from datetime import datetime from typing import Any , Dict from aiocli.commander import Application , run_app from aiocli.commander_app import Command , CommandArgument def info_middleware ( cmd : Command , args : Dict [ str , Any ]) -> None : print ( f 'Command: { cmd . name } Arguments: { args } ' ) app = Application ( middleware = [ info_middleware ]) @app . middleware () async def time_middleware () -> None : print ( f 'Time: { datetime . now () } ' ) @app . command ( name = 'greet:to' , positionals = [ CommandArgument ( name_or_flags = '--name' )]) async def handle_greeting ( name : str ) -> int : print ( f 'Hello { name } ' ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'greet:to' , '--name' , 'middleware!' ])","title":"Middleware"},{"location":"es/advanced/serverless_support/","text":"con AWS Lambda : from aiocli.commander import Application from aiocli.commander_app_wrappers import aws_run_app app = Application () def _parser ( event , context ) -> list [ str ]: pass handler = aws_run_app ( app , parser = _parser ) con Azure Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import az_run_app app = Application () def _parser ( req , context ) -> list [ str ]: pass handler = az_run_app ( app , parser = _parser ) con Google Cloud Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import gcp_run_app app = Application () def _http_parser ( request ) -> list [ str ]: pass http_handler = gcp_run_app ( app , parser = _http_parser ) def _event_parser ( event_or_data , context ) -> list [ str ]: pass event_handler = gcp_run_app ( app , parser = _event_parser ) con Alibaba Cloud Function Compute : from aiocli.commander import Application from aiocli.commander_app_wrappers import alibaba_run_app app = Application () def _http_parser ( environ , start_response ) -> list [ str ]: pass http_handler = alibaba_run_app ( app , parser = _http_parser ) def _event_parser ( event , context ) -> list [ str ]: pass event_handler = alibaba_run_app ( app , parser = _event_parser ) con Oracle Cloud Function : from aiocli.commander import Application from aiocli.commander_app_wrappers import oracle_run_app app = Application () def _parser ( ctx , data ) -> list [ str ]: pass handler = oracle_run_app ( app , parser = _parser )","title":"Serverless support"},{"location":"es/advanced/state/","text":"El State en aiocli nos permite mantener nuestras dependencias en la aplicaci\u00f3n y modificarlo (si es necesario) d\u00f3nde queramos. from aiocli.commander import Application , run_app from aiocli.commander_app import State app = Application ( state = { 'hello' : 'world' }) @app . command ( name = 'show:state' ) async def handle_show_state ( state : State ) -> int : print ( state ) return 0 if __name__ == '__main__' : run_app ( app , argv = [ 'show:state' ])","title":"State"},{"location":"es/advanced/test_support/","text":"Has utilizado el plugin pytest-aiohttp ? Esto est\u00e1 inspirado en ello. # code: python3 <file.py> <command> <positionals> <optionals> from aiocli.commander import run_app , Application app = Application ( default_exit_code = 1 ) @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World' })]) async def handle_greeting ( name : str ) -> int : print ( f 'Hello { name } ' ) return 0 if __name__ == '__main__' : run_app ( app ) # test: pytest <test_file.py> from aiocli.test_utils import TestClient , TestCommander import pytest @pytest . mark . asyncio async def test_handle_greeting_command () -> None : commander = TestCommander ( app ) client = TestClient ( commander ) try : await commander . start_commander () args = 'greet:to --name aiocli' exit_code = await client . handle ( args . split ( ' ' ), timeout = float ( 1 ), timeout_exit_code = 134 , ) assert exit_code == 0 finally : await commander . close ()","title":"Test support"}]}